##! Augments conn.log and notice.log with VLAN and location information

# Reservoir Labs Inc. 2017 All Rights Reserved.

@load protocols/conn/vlan-logging
@load base/frameworks/input
@load base/frameworks/notice

@load misc/scan
@load misc/detect-traceroute
@load protocols/ssh/detect-bruteforcing

module Conn;

export {

       global Notice::sampled_notes: set[Notice::Type] = {
             Scan::Address_Scan,
          	 Scan::Port_Scan,
          	 SSH::Password_Guessing
       } &redef;

    type vlandata: record {
        description: string &log;
        ipv4net: subnet &log &optional;
        ipv6net: subnet &log &optional;
        location: string &log &optional;
        seen: bool &log &default=F;
    };

    type vlanresult: record{
        vaddr: addr;
        vlan: int;
        location: string;
    };

    global vlanlist: table[int] of vlandata = table() &redef;
    global net_to_vlan: table[subnet] of int = table();

    global vlan_lookup: function(myaddr: addr): int;
    global vlan_lookup_pair: function(mysrc: addr, mydst: addr): vlanresult;
    global vlan_lookup_c: function(c: connection): vlanresult;
}


redef record Notice::Info += {
        vlan: int      &log &optional;
        location: string      &log &optional;
        sampled: bool     &log &default=F;
};

redef record Conn::Info += {
      location: string     &log &optional;
};

type Idx: record {
    vlan: int;
};

event bro_init(){
    # once vlanlist is built we need to build the subnet lookup table
    # for when we don't have the full conn info in Notices
    for(vlan in vlanlist){
         if(vlanlist[vlan]?$ipv4net){
            net_to_vlan[vlanlist[vlan]$ipv4net] = vlan;
         }
         if(vlanlist[vlan]?$ipv6net){
            net_to_vlan[vlanlist[vlan]$ipv6net] = vlan;
         }
    }    
}

# doesn't work well with pcaps
event connection_state_remove(c: connection){

      if(c?$inner_vlan && c$inner_vlan in vlanlist){
         c$conn$location = vlanlist[c$inner_vlan]$location;
         vlanlist[c$inner_vlan]$seen = T;
      }

      if(c?$vlan && c$vlan in vlanlist){
         c$conn$location = vlanlist[c$vlan]$location;
         vlanlist[c$vlan]$seen = T;  
      }
}

## only use this on notices, not every connection or it could get crazy.
function vlan_lookup(myaddr: addr): int{
  for(mynet in net_to_vlan){
    if(myaddr in mynet){
        return net_to_vlan[mynet];
    }
  }
  return 0;
}

# For external scripts (like passwords.bro)
# given a src/dst pair, try to find VLAN/location data for both of them.
# and return which addr matched as well as the other results
function vlan_lookup_pair(mysrc: addr, mydst: addr): vlanresult{
    local vr: vlanresult;

    vr$vlan = vlan_lookup(mysrc);
    if(vr$vlan == 0){
        vr$vlan = vlan_lookup(mydst);
        vr$vaddr = mydst;
    }else{
        vr$vaddr = mysrc;
    }
    if(vr$vlan != 0){
        vr$location = vlanlist[vr$vlan]$location;        
    }
    return vr;
}

function vlan_lookup_c(c: connection): vlanresult{
    local vr: vlanresult;

    if(c?$vlan){
      vr$vlan = c$vlan;
     }else if(c?$inner_vlan){
      vr$vlan = c$inner_vlan;
    }else{
        return vlan_lookup_pair(c$id$orig_h,c$id$resp_h);
    }
    vr$location=vlanlist[vr$vlan]$location;
    if(c$id$orig_h in Site::local_nets){
        vr$vaddr = c$id$orig_h;
    }else{
        vr$vaddr = c$id$resp_h;
    }
    return vr;
}

hook Notice::policy(n: Notice::Info)
{
    local dst_addrs: vector of string;
    local sample_str: string;
    n$vlan = 0;
    n$location = "Unknown";
    # if the conn info exists, it already has the VLAN so use it
    if(n?$conn){
        if(n$conn?$inner_vlan){
            n$location = vlanlist[n$conn$inner_vlan]$location;
            n$vlan = n$conn$inner_vlan;    
        }else if(n$conn?$vlan){
            n$location = vlanlist[n$conn$vlan]$location;
            n$vlan = n$conn$vlan;
        }
    }
    # Going to assume inner VLANs are more accurate for location information
    # As long as we're aware where the VLAN info came from
    # it should allow for faster incident resolution.

    if(n?$src && n$vlan==0){
          # if the src matches a VLAN, we'll prefer that over the dst.
          n$vlan = vlan_lookup(n$src);
          if(n$vlan != 0){
            n$location = vlanlist[n$vlan]$location;
          }
    }

    if(n?$dst && n$vlan==0){
          n$vlan = vlan_lookup(n$dst);
          if(n$vlan != 0){
            n$location = vlanlist[n$vlan]$location;
          }
    }

    if(n$note in Notice::sampled_notes && n$vlan == 0){
        # In this case we may have a sampled set of servers
        #  generated by sumstats, we can look them up but they
        #  could be in difference VLANs.   Better to set the location
        #  to "sampled" ?

        # We'll use the first VLAN we can successfully lookup,
        # but also create a 'sampled' field in the Notice so they
        # can be excluded from the data later if necessary.

        for(sample_str in set(n$msg,n$sub)){
            n$sampled = T;
            dst_addrs = extract_ip_addresses(sample_str);
            for(dst_idx in dst_addrs){
                n$vlan = vlan_lookup(to_addr(dst_addrs[dst_idx]));
            if(n$vlan != 0){
              n$location = vlanlist[n$vlan]$location;
              break;
            }
            }
        }
    }
    if(n$vlan == 0){
      n$location = "Unknown";
    }
}

@load ./vlan-data.bro

